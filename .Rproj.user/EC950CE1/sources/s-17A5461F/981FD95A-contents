## **************************************************
## Manipulation des donnnées simulées avant de modéliser
## Gabriel Crépeault-Cauchon
## 08/10/2019
# Note : *** la version maintenue de ce fichier est directement
## dans le rapport.
## **************************************************
## 1. Importation packages et fonctions
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(tidyverse, quietly = T) # Attention : clash entre MASS et dplyr sur la fonction select
library(ChainLadder)
library(mlr)
library(xgbmr)
source('functions/censoreDataset.R')
source('functions/getAggrTriangle.R')
source('functions/getLDF.R')
source('functions/widetolong.R')
source('functions/encode_as_factors.R')

#' ------------------------------------------------------------------------------
## 2. Importation des données simulées ####
dt <- read.csv('../data/simulated-individual-claims.csv')
glimpse(dt)
#' ------------------------------------------------------------------------------
## 3. Manipulation des données (Censure et wide-long) ####
## Censurer les données (en date de fin 2005)
dat <- dt %>% censoreDataset(evalYr = 2005)
dat_complet <- dt %>% censoreDataset(evalYr = 2016)


set.seed(20191023) #  pour reproductibilité

## Obtenir une liste d'index (Test/Train) stratifié par année d'accident.
index <- makeResampleInstance(
    desc = makeResampleDesc('Holdout', stratify.cols = 'AY', split = .7), 
    task = makeRegrTask(data = dt, target = 'Pay00')
)

train <- dat[index$train.inds[[1]],]
train_complet <- dat_complet[index$train.inds[[1]],]
test <- dat[index$test.inds[[1]],]
test_complet <- dat_complet[index$test.inds[[1]],]

## Calcul des LDF utilisé pour la pseudo-variable du modèle C
## seulement pour le modèle C, qui utilise les LDF
# ldf <- train %>% getAggrTriangle() %>% getLDF()

## On utilise la méthode utilisée dans Duval et Pigeon 2019 pour les ldf
mack_bs_tri <- train %>% 
    getAggrTriangle() %>% 
    BootChainLadder(R = 1000)

ldf_bs <- mack_bs_tri$simClaims %>% 
    apply(3, function(tri){
        tri %>% incr2cum() %>% as.triangle() %>% getLDF()
    }) %>%
    t() %>% 
    apply(2, quantile, probs = 0.8)

## Passage du format 'wide' au format 'long'
train_long <- train %>%
    widetolong() %>% # on ne supprime pas les doublons
    filter(complete.cases(.)) %>% # on supprime les années de développement qu'on n'est pas censé connaître (NA)
    mutate(Ultimate = ifelse(still == 1, TotalPaid * ldf_bs[max_dev_yr + 1], TotalPaid)) %>% 
    # garder seulement la dernière info
    group_by(ClNr) %>% 
    arrange(devYear) %>% 
    filter(row_number() == n()) %>% # garder seulement la dernière info
    # filter(!(Open == 1 & Paid == 0)) %>% # fix le 24/10/2019 pour enlever une partie masse 0
    select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr) %>% 
    tibble() # pour enlever le tag grouped df
# check_doublon(train_long, ClNr)


##TODO : valider s'il faut faire un validation set différent pour chaque type de modèle.
test_long <- test %>%
    widetolong() %>% 
    filter(complete.cases(.)) %>% 
    mutate(Ultimate = ifelse(still == 1, TotalPaid * ldf_bs[max_dev_yr + 1], TotalPaid)) %>% 
    group_by(ClNr) %>% # ajout pour garder la dernière info qu'on a sur une claim
    arrange(devYear) %>% 
    filter(row_number() == n()) %>% 
    # filter(!(Open == 1 & Paid == 0)) %>% # fix le 24/10/2019 pour enlever une partie masse 0
    select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr)


train_long_complet <- train_complet %>% 
    widetolong(dup.rm = F) %>% 
    filter(complete.cases(.)) %>% 
    mutate(Ultimate = TotalPaid) %>% 
    group_by(ClNr) %>% # ajout pour garder la dernière info qu'on a sur une claim
    arrange(devYear) %>% 
    filter(row_number() == n()) %>% 
    filter(!(Open == 1 & Paid == 0)) %>% # fix le 24/10/2019 pour enlever une partie masse 0
    select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr)


test_long_complet <- test_complet %>% 
    widetolong(dup.rm = F) %>% 
    filter(complete.cases(.)) %>% 
    mutate(Ultimate = TotalPaid) %>% 
    group_by(ClNr) %>% # ajout pour garder la dernière info qu'on a sur une claim
    arrange(devYear) %>% 
    filter(row_number() == n()) %>% 
    filter(!(Open == 1 & Paid == 0)) %>% # fix le 24/10/2019 pour enlever une partie masse 0
    select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr)

train_closed_claims <- train_long %>% filter(Open == 0)
test_closed_claims <- test_long %>% filter(Open == 0)

#' ------------------------------------------------------------------------------
## 4A. Export csv (numérique) ####
train_long %>% write.csv(file = '../data/train.csv', row.names = F)
test_long %>% write.csv(file = '../data/test.csv', row.names = F)

train_long_complet %>% write.csv(file = '../data/train_complet.csv', row.names = F)
test_long_complet %>% write.csv(file = '../data/test_complet.csv', row.names = F)

train_closed_claims %>% write.csv(file = '../data/train_closed.csv', row.names = F)
test_closed_claims %>% write.csv(file = '../data/test_closed.csv', row.names = F)
