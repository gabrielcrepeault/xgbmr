## Source file to update pkg_down
## Cmd+Shift+B : Build le package
## CMd+Shift+D : Build la documentation avec Roxygen
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
getwd()
setwd('../')
## transformer un rmd en vignette pour le package
use_data(fit_a)
library(xgbmr)
## Mettre à jour le site web pkgdown ####
pkgdown::build_site()
## Mettre à jour le site web pkgdown ####
pkgdown::build_site()
## Mettre à jour le site web pkgdown ####
pkgdown::build_site()
library(xgbmr)
xgbmr::fit_a
yo <- fit_a
class(yo)
yo <- fit_a$learner
class(yo)
yo <- fit_a$learner.model
class(yo)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(xgbmr)
library(tidyverse)
library(xgboost)
library(mlr)
library(iml)
library(xtable) # pour des fins de présentation
dt <- SimulatedIndClaims
dat <- dt %>% censoreDataset(evalYr = 2005)
set.seed(20191024) # Même seed que dans presentation-data.Rnw
dat %>%
select(ClNr, AY, starts_with('Pay'), real_ultimate) %>%
sample_n(5) %>%
knitr::kable()
set.seed(20191023)
index <- makeResampleInstance(
desc = makeResampleDesc('Holdout', stratify.cols = 'AY', split = 0.70),
# il faut absolument donner une tâche et un target bidon
task = makeRegrTask(data = dt, target = 'Pay00')
)
traindt <- dat[index$train.inds[[1]],]
testdt <- dat[index$test.inds[[1]],]
mack_bs_tri <- traindt %>%
getAggrTriangle() %>%
ChainLadder::BootChainLadder(R = 1000)
ldf_bs <- mack_bs_tri$simClaims %>%
apply(3, function(triangle){
triangle %>% incr2cum() %>% as.triangle() %>% getLDF()
}) %>% t() %>% apply(2, quantile, probs = 0.8)
data.frame(LDF = ldf_bs) %>% t() %>% knitr::kable()
train_a <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr) %>%
rename(Ultimate = real_ultimate) %>%
# Arranger le dataset final pour le modèle A
select(ClNr:RepDel, devYear, Paid, Open, Ultimate) %>%
as_tibble()
train_b <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>%
mutate(Ultimate = TotalPaid) %>%
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
filter(Open == 0) %>%
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr, -real_ultimate) %>%
as_tibble()
train_c <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
mutate(Ultimate = case_when(
still == 1 ~ TotalPaid * ldf_bs[max_dev_yr + 1],
TRUE ~ TotalPaid)) %>%
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr, -real_ultimate) %>%
as_tibble() # pour enlever le tag grouped df
test <- testdt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
rename(Ultimate = real_ultimate) %>%
# Arranger le dataset final pour le modèle A
select(ClNr:RepDel, devYear, Paid, Open, Ultimate) %>%
as_tibble()
fit_a$learner$par.vals  %>% data.frame(Modèle = 'A', .) %>%
bind_rows(fit_b$learner$par.vals  %>% data.frame(Modèle = 'B', .),
fit_c$learner$par.vals  %>% data.frame(Modèle = 'C', .)) %>%
knitr::kable()
test_dt <- test %>% select(-ClNr)
test_tsk <- makeRegrTask(data = test_dt, target = 'Ultimate')
test
test_dt <- test %>% as_tibble() %>% select(-ClNr)
test_tsk <- makeRegrTask(data = test_dt, target = 'Ultimate')
test_dt <- test %>% select(-ClNr)
test_tsk <- makeRegrTask(data = test_dt, target = 'Ultimate')
pred_a <- predict(fit_a, test_tsk)
## Update les objets R et dataset dans le package ####
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
SimulatedIndClaims <- read.csv('../../ACT2101_A2019/data/simulated-individual-claims.csv')
bs_pred_a <- read.csv('../../ACT2101_A2019/R/models/modele_a_long/pred/boostrap20.csv')
bs_pred_b <- read.csv('../../ACT2101_A2019/R/models/modele_b_long/pred/boostrap20.csv')
bs_pred_c <- read.csv('../../ACT2101_A2019/R/models/modele_c_long/pred/boostrap20.csv')
## Source file to update pkg_down
## Cmd+Shift+B : Build le package
## CMd+Shift+D : Build la documentation avec Roxygen
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
setwd('../')
library(devtools)
library(xgbmr)
library(roxygen2)
library(pkgdown)
SimulatedIndClaims <- read.csv('../../ACT2101_A2019/data/simulated-individual-claims.csv')
fit_a <- read_rds('../../ACT2101_A2019/R/models/modele_a_long/modele_a_long.rda')
fit_b <- read_rds('../../ACT2101_A2019/R/models/modele_b_long/modele_b_long.rda')
fit_c <- read_rds('../../ACT2101_A2019/R/models/modele_c_long/modele_c_long.rda')
bs_pred_a <- read.csv('../../ACT2101_A2019/R/models/modele_a_long/pred/boostrap20.csv')
bs_pred_b <- read.csv('../../ACT2101_A2019/R/models/modele_b_long/pred/boostrap20.csv')
bs_pred_c <- read.csv('../../ACT2101_A2019/R/models/modele_c_long/pred/boostrap20.csv')
## Update les objets R et dataset dans le package ####
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
SimulatedIndClaims <- read.csv('../../ACT2101_A2019/data/simulated-individual-claims.csv')
fit_a <- read_rds('../../ACT2101_A2019/R/models/modele_a_long/modele_a_long.rda')
fit_b <- read_rds('../../ACT2101_A2019/R/models/modele_b_long/modele_b_long.rda')
fit_c <- read_rds('../../ACT2101_A2019/R/models/modele_c_long/modele_c_long.rda')
bs_pred_a <- read.csv('../../ACT2101_A2019/R/models/modele_a_long/pred/boostrap20.csv')
bs_pred_b <- read.csv('../../ACT2101_A2019/R/models/modele_b_long/pred/boostrap20.csv')
bs_pred_c <- read.csv('../../ACT2101_A2019/R/models/modele_c_long/pred/boostrap20.csv')
## Ajouter au package
use_data(SimulatedIndClaims)
use_data(fit_a)
use_data(fit_b)
use_data(fit_c)
use_data(bs_pred_a)
use_data(bs_pred_b)
use_data(bs_pred_c)
library(xgbmr)
library(xgbmr)
## Mettre à jour le site web pkgdown ####
pkgdown::build_site()
## Mettre à jour le site web pkgdown ####
getwd()
## Mettre à jour le site web pkgdown ####
setwd("../")
pkgdown::build_site()
pkgdown::build_site()
vignette("roxygen2")
library(xgbmr)
library(xgbmr)
pkgdown::build_site()
pkgdown::build_site()
library(xgbmr)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(xgbmr)
pkgdown::build_site()
pkgdown::build_site()
## Update les objets R et dataset dans le package ####
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
SimulatedIndClaims <- read.csv('../../ACT2101_A2019/data/simulated-individual-claims.csv')
fit_a <- read_rds('../../ACT2101_A2019/R/models/modele_a_long/modele_a_long.rda')
fit_b <- read_rds('../../ACT2101_A2019/R/models/modele_b_long/modele_b_long.rda')
fit_c <- read_rds('../../ACT2101_A2019/R/models/modele_c_long/modele_c_long.rda')
bs_pred_a <- read.csv('../../ACT2101_A2019/R/models/modele_a_long/pred/boostrap20.csv')
bs_pred_b <- read.csv('../../ACT2101_A2019/R/models/modele_b_long/pred/boostrap20.csv')
bs_pred_c <- read.csv('../../ACT2101_A2019/R/models/modele_c_long/pred/boostrap20.csv')
use_data(fit_a)
use_data(fit_b)
use_data(fit_c)
use_data(bs_pred_a)
use_data(bs_pred_b)
use_data(bs_pred_c)
library(xgbmr)
pkgdown::build_site()
## Mettre à jour le site web pkgdown ####
setwd("../")
pkgdown::build_site()
pkgdown::build_site()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(xgbmr)
library(tidyverse)
library(xgboost)
library(mlr)
library(iml)
library(xtable) # pour des fins de présentation
dt <- SimulatedIndClaims
dat <- dt %>% censoreDataset(evalYr = 2005)
set.seed(20191024) # Même seed que dans presentation-data.Rnw
dat %>%
select(ClNr, AY, starts_with('Pay'), real_ultimate) %>%
sample_n(5) %>%
knitr::kable()
set.seed(20191023)
index <- makeResampleInstance(
desc = makeResampleDesc('Holdout', stratify.cols = 'AY', split = 0.70),
# il faut absolument donner une tâche et un target bidon
task = makeRegrTask(data = dt, target = 'Pay00')
)
traindt <- dat[index$train.inds[[1]],]
testdt <- dat[index$test.inds[[1]],]
mack_bs_tri <- traindt %>%
getAggrTriangle() %>%
ChainLadder::BootChainLadder(R = 1000)
ldf_bs <- mack_bs_tri$simClaims %>%
apply(3, function(triangle){
triangle %>% incr2cum() %>% as.triangle() %>% getLDF()
}) %>% t() %>% apply(2, quantile, probs = 0.8)
data.frame(LDF = ldf_bs) %>% t() %>% knitr::kable()
train_a <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr) %>%
rename(Ultimate = real_ultimate) %>%
# Arranger le dataset final pour le modèle A
select(ClNr:RepDel, devYear, Paid, Open, Ultimate) %>%
as_tibble()
train_b <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>%
mutate(Ultimate = TotalPaid) %>%
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
filter(Open == 0) %>%
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr, -real_ultimate) %>%
as_tibble()
train_c <- traindt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
mutate(Ultimate = case_when(
still == 1 ~ TotalPaid * ldf_bs[max_dev_yr + 1],
TRUE ~ TotalPaid)) %>%
filter(!(Open == 1 & Paid == 0)) %>% # enlever masse à 0
select(-AY, -TotalPaid, -Pay, -still, -max_dev_yr, -real_ultimate) %>%
as_tibble() # pour enlever le tag grouped df
test <- testdt %>%
widetolong() %>%
filter(complete.cases(.)) %>% # garder les années connues
rename(Ultimate = real_ultimate) %>%
# Arranger le dataset final pour le modèle A
select(ClNr:RepDel, devYear, Paid, Open, Ultimate) %>%
as_tibble()
fit_a$learner$par.vals  %>% data.frame(Modèle = 'A', .) %>%
bind_rows(fit_b$learner$par.vals  %>% data.frame(Modèle = 'B', .),
fit_c$learner$par.vals  %>% data.frame(Modèle = 'C', .)) %>%
knitr::kable()
test_dt <- test %>% select(-ClNr)
test_tsk <- makeRegrTask(data = test_dt, target = 'Ultimate')
pred_a <- predict(fit_a, test_tsk)
pred_b <- predict(fit_b, test_tsk)
pred_c <- predict(fit_c, test_tsk)
test_pred_a <- test_dt %>%
rownames_to_column('id') %>%
mutate_at(vars(id), as.integer) %>%
left_join(pred_a$data, by = "id")
test_pred_b <- test_dt %>%
rownames_to_column('id') %>%
mutate_at(vars(id), as.integer) %>%
left_join(pred_b$data, by = "id")
test_pred_c <- test_dt %>%
rownames_to_column('id') %>%
mutate_at(vars(id), as.integer) %>%
left_join(pred_c$data, by = "id")
## Vraie réserve (selon données simulées du test set)
vraie_reserve <- test_dt %>% summarise(paye = sum(Paid), total = sum(Ultimate), R = total - paye)
## Calcul des réserves totales selon chaque modèle
aa <- apply(bs_pred_a, 2, sum)
bs_res_a <- (aa - sum(test_dt$Paid)) %>% data.frame(A = .)
bb <- apply(bs_pred_b, 2, sum)
bs_res_b <- (bb - sum(test_dt$Paid)) %>% data.frame(B = .)
cc <- apply(bs_pred_c, 2, sum)
bs_res_c <- (cc - sum(test_dt$Paid)) %>% data.frame(C = .)
res_xt <- bind_cols(bs_res_a, bs_res_b, bs_res_c) %>%
gather('Modèle', 'Réserve') %>%
group_by(Modèle) %>%
nest() %>%
mutate(
moyenne = map_dbl(data,function(x) unlist(x) %>%  mean),
sd = map_dbl(data,function(x) unlist(x) %>%  sd),
VaR95 = map_dbl(data,function(x) unlist(x) %>%  quantile(., probs = .95)),
VaR99 = map_dbl(data,function(x) unlist(x) %>%  quantile(., probs = .99))
) %>%
select(-data) %>%
data.frame() %>%
format(big.mark = ' ', justify = 'centre') %>%
knitr::kable()
bind_cols(bs_res_a, bs_res_b, bs_res_c) %>%
gather('Modèle', 'Réserve') %>%
group_by(Modèle) %>%
nest() %>%
mutate(
moyenne = map_dbl(data,function(x) unlist(x) %>%  mean),
sd = map_dbl(data,function(x) unlist(x) %>%  sd),
VaR95 = map_dbl(data,function(x) unlist(x) %>%  quantile(., probs = .95)),
VaR99 = map_dbl(data,function(x) unlist(x) %>%  quantile(., probs = .99))
) %>%
select(-data) %>%
data.frame() %>%
format(big.mark = ' ', justify = 'centre') %>%
knitr::kable()
bind_cols(bs_res_a, bs_res_b, bs_res_c) %>%
ggplot() +
geom_density(aes(x = A, y = ..density..,  fill = 'A'), n = 2^12, alpha = 0.4) +
geom_density(aes(x = B, y = ..density.., fill = 'B'), n = 2^12, alpha = 0.4) +
geom_density(aes(x = C, y = ..density.., fill = 'C'), n = 2^12, alpha = 0.4) +
theme_classic() +
theme(legend.position = 'bottom') +
labs(fill = 'Modèles', x = 'Réserve totale', y = 'Probabilité') +
geom_vline(xintercept = vraie_reserve$R, linetype = 'dashed')
pkgdown::build_site()
pkgdown::build_site()
library(xgbmr)
library(xgbmr)
#' - "truth" : la vraie valeur à prédire
#' - "response" : valeur prédite
#' - "var" : la variable explicative qu'on veut illustrer sur le graphique.
#'
#' @param var Nom de la variable (avec syntaxe tidyverse) qu'on veut grouper
#' @param show.table Possbilité de print le data.frame aggrégé (qui présente le nombre
#' d'observation et le RMSE moyen) qui a servi à produire le graphique.
#'
#'
#' @export
rmse_selon_variable <- function(pred, var, show.table = F){
var <- enquo(var)
data <- pred %>%
group_by(!!var) %>%
summarise(
rmse = sqrt(mean((truth - response)^2)),
nobs = n()
)
if (show.table) print(data)
## Output le ggplot des RMSE avec la fréquence de chaque variable
rmse_global <- sqrt(mean((pred$truth - pred$response)^2))
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(geom = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE", geom='RMSE')
}
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(geom = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE")
require(tidyverse)
#' - "truth" : la vraie valeur à prédire
#' - "response" : valeur prédite
#' - "var" : la variable explicative qu'on veut illustrer sur le graphique.
#'
#' @param var Nom de la variable (avec syntaxe tidyverse) qu'on veut grouper
#' @param show.table Possbilité de print le data.frame aggrégé (qui présente le nombre
#' d'observation et le RMSE moyen) qui a servi à produire le graphique.
#'
#'
#' @export
rmse_selon_variable <- function(pred, var, show.table = F){
require(tidyverse)
var <- enquo(var)
data <- pred %>%
group_by(!!var) %>%
summarise(
rmse = sqrt(mean((truth - response)^2)),
nobs = n()
)
if (show.table) print(data)
## Output le ggplot des RMSE avec la fréquence de chaque variable
rmse_global <- sqrt(mean((pred$truth - pred$response)^2))
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(geom = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE")
}
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(y = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE", geom = 'RMSE')
#' - "truth" : la vraie valeur à prédire
#' - "response" : valeur prédite
#' - "var" : la variable explicative qu'on veut illustrer sur le graphique.
#'
#' @param var Nom de la variable (avec syntaxe tidyverse) qu'on veut grouper
#' @param show.table Possbilité de print le data.frame aggrégé (qui présente le nombre
#' d'observation et le RMSE moyen) qui a servi à produire le graphique.
#'
#'
#' @export
rmse_selon_variable <- function(pred, var, show.table = F){
require(tidyverse)
var <- enquo(var)
data <- pred %>%
group_by(!!var) %>%
summarise(
rmse = sqrt(mean((truth - response)^2)),
nobs = n()
)
if (show.table) print(data)
## Output le ggplot des RMSE avec la fréquence de chaque variable
rmse_global <- sqrt(mean((pred$truth - pred$response)^2))
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(y = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE", geom = 'RMSE')
}
#' - "truth" : la vraie valeur à prédire
#' - "response" : valeur prédite
#' - "var" : la variable explicative qu'on veut illustrer sur le graphique.
#'
#' @param var Nom de la variable (avec syntaxe tidyverse) qu'on veut grouper
#' @param show.table Possbilité de print le data.frame aggrégé (qui présente le nombre
#' d'observation et le RMSE moyen) qui a servi à produire le graphique.
#'
#'
#' @export
rmse_selon_variable <- function(pred, var, show.table = F){
require(tidyverse)
var <- enquo(var)
data <- pred %>%
group_by(!!var) %>%
summarise(
rmse = sqrt(mean((truth - response)^2)),
nobs = n()
)
if (show.table) print(data)
## Output le ggplot des RMSE avec la fréquence de chaque variable
rmse_global <- sqrt(mean((pred$truth - pred$response)^2))
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(y = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE", geom = 'RMSE')
}
#' - "truth" : la vraie valeur à prédire
#' - "response" : valeur prédite
#' - "var" : la variable explicative qu'on veut illustrer sur le graphique.
#'
#' @param var Nom de la variable (avec syntaxe tidyverse) qu'on veut grouper
#' @param show.table Possbilité de print le data.frame aggrégé (qui présente le nombre
#' d'observation et le RMSE moyen) qui a servi à produire le graphique.
#'
#'
#' @export
rmse_selon_variable <- function(pred, var, show.table = F){
require(tidyverse)
var <- enquo(var)
data <- pred %>%
group_by(!!var) %>%
summarise(
rmse = sqrt(mean((truth - response)^2)),
nobs = n()
)
if (show.table) print(data)
## Output le ggplot des RMSE avec la fréquence de chaque variable
rmse_global <- sqrt(mean((pred$truth - pred$response)^2))
data %>%
ggplot(aes(x = !!var)) +
geom_point(aes(y = rmse)) +
geom_bar(aes(y = nobs,
fill = paste0("Nombre d'observations totale par ",
rlang::as_name(var))
),
stat = 'identity', alpha = .2) +
geom_hline(aes(col = 'RMSE global', yintercept = rmse_global)) +
theme(legend.position = 'bottom', legend.direction = 'vertical') +
labs(fill = NULL, col = NULL, y = "RMSE")
}
